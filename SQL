一、了解SQL

1、什么是SQL

1.1 SQL的定义

SQL（Structured Query Language）全称结构化查询语言，是一门与数据库沟通的语言。与数据库沟通的意思就是从数据库中读写数据。

从下图（粗糙了）中我们可了解到，学习SQL前，需要先简单了解下DBMS和数据库的基本知识。


SQL语言-数据库操作系统-数据库
1.2 SQL的优势

是绝大多数的数据库关系系统的通用语言；简单易学；功能强大，能进行复杂的数据库操作。

2、数据库的基础知识

2.1 数据库和数据库管理系统

数据库管理系统DBMS是指操控和管理数据库的应用软件。

市场上比较流行的数据库管理系统产品主要是Oracle、IBM、Microsoft和Sybase、Mysql等公司的产品。

自己学习用MySQL workbench、或者Navicat比较方便。

数据库就是存储有组织数据的容器。

我们可以将数据库想象成一个文件夹，文件夹里放着一个个文件就是表，表中存放着行行列列的数据。、

bizhibihui就是数据库，customers、orderitems等就是表。

类比到Excel中，一个数据库就对应一个Excel文件，里面的customers、orderitems等就对应一个个sheet表。


数据库
2.2 表是什么

表是结构化的文件，存储特定类型的数据。

用来描述表或数据库布局及特性的信息叫做模式（schema）。模式包含表中存储什么，如何存储，各部分信息如何命名，数据库中表与表之间的关系等等这些信息。

2.2.1 行和列

表是由行和列组成。

列：表中的一个个字段，代表特定信息，每一列有相应的数据类型。

行：表的一条条记录，表中的数据按行存储，每一行可以设置唯一的标识。

2.2.2 数据类型（列）

每列对应的数据类型规定了该列所有的数据必须是同样的数据类型，比如消费金额一列都必须是浮点型。


SQL数据类型
2.2.3 主键（标识行）

唯一标识表中每一行的某一列（或多列）称为主键。

大部分数据库设计者在设计的时候都会保证表中至少有一个主键，方便后续数据库管理和操作。

任何列可以称为主键的条件：任意行非空且唯一、任意两行不重复、任意行的值删除后不能复用。

了解完SQL沟通的对象之后，就可以接着了解语言本身了。

二、课后习题

本书第2-18章讲了SQL查询语句，每章节后面都留有挑战题。

挑战题样例数据：


样例数据
课2 检索数据

1．编写SQL语句，从Customers表中检索所有的ID（cust_id）。

select cust_id from Customers;
2．OrderItems表包含了所有已订购的产品（有些已被订购多次）。编写SQL语句，检索并列出已订购产品（prod_id）的清单（不用列每个订单，只列出不同产品的清单）。提示：最终应该显示7行。

select distinct prod_id from OrderItems;
3．编写SQL语句，检索Customers表中所有的列，再编写另外的SELECT语句，仅检索顾客的ID。使用注释，注释掉一条SELECT语句，以便运行另一条SELECT语句。（当然，要测试这两个语句。）

-- select * 
select cust_id 
from Customers;
课3 排序检索数据

1．编写SQL语句，从Customers中检索所有的顾客名称（cust_names），并按从Z到A的顺序显示结果。

select cust_name from Customers order by cust_name desc;
2．编写SQL语句，从Orders表中检索顾客ID（cust_id）和订单号（order_num），并先按顾客ID对结果进行排序，再按订单日期倒序排列。

select cust_id,order_num from Orders order by cust_id,order_date desc;
3．显然，我们的虚拟商店更喜欢出售比较贵的物品，而且这类物品有很多。编写SQL语句，显示OrderItems表中的数量和价格（item_price），并按数量由多到少、价格由高到低排序。

select quantity,item_price from orderitems order by quantity desc, item_price desc;
4．下面的SQL语句有问题吗？（尝试在不运行的情况下指出。）

      SELECT vend_name,  # 错误1：查询的最后一个字段后面不需要加逗号
      FROM Vendors
      ORDER vend_name DESC;  # 错误2：order by
课4 过滤数据

1．编写SQL语句，从Products表中检索产品ID（prod_id）和产品名称（prod_name），只返回价格为9.49美元的产品。

select prod_id, prod_name from Products where prod_price = 9.49;
2．编写SQL语句，从Products表中检索产品ID（prod_id）和产品名称（prod_name），只返回价格为9美元或更高的产品。

select prod_id, prod_name from Products where prod_price >= 9;
3．结合第3课和第4课编写SQL语句，从OrderItems表中检索出所有不同订单号（order_num），其中包含100个或更多的产品。

select distinct order_num from orderitems where quantity>=100;
4．编写SQL语句，返回Products表中所有价格在3美元到6美元之间的产品的名称（prod_name）和价格（prod_price），然后按价格对结果进行排序。（本题有多种解决方案，我们在下一课再讨论，不过你可以使用目前已学的知识来解决它。）

select prod_name, prod_price from Products where prod_price between 3 and 6;
课5 高级数据过滤

1．编写SQL语句，从Vendors表中检索供应商名称（vend_name），仅返回加利福尼亚州的供应商（这需要按国家[USA]和州[CA]进行过滤，没准其他国家也存在一个加利福尼亚州）。提示：过滤器需要匹配字符串。

select vend_name from Vendors where vend_country ='USA' and vend_state='CA';
2．编写SQL语句，查找所有至少订购了总量100个的BR01、BR02或BR03的订单。你需要返回OrderItems表的订单号（order_num）、产品ID（prod_id）和数量，并按产品ID和数量进行过滤。提示：根据编写过滤器的方式，可能需要特别注意求值顺序。

select order_num, prod_id, quantity 
from orderitems 
where prod_id in ('BR01','BR02','BR03') 
and quantity>=100;
3．现在，我们回顾上一课的挑战题。编写SQL语句，返回所有价格在3美元到6美元之间的产品的名称（prod_name）和价格（prod_price）。使用AND，然后按价格对结果进行排序。

select prod_name, prod_price from Products where prod_price>=3 and prod_price<=6;
4．下面的SQL语句有问题吗？（尝试在不运行的情况下指出。）

SELECT vend_name
FROM Vendors
ORDER BY vend_name
WHERE vend_country = 'USA' AND vend_state = 'CA';  

# where 语句应当放到order by 前面。
SELECT vend_name
FROM Vendors
WHERE vend_country = 'USA' AND vend_state = 'CA'; 
ORDER BY vend_name
课6 用通配符过滤

1．编写SQL语句，从Products表中检索产品名称（prod_name）和描述（prod_desc），仅返回描述中包含toy一词的产品。

select prod_name, prod_desc from Products where prod_desc like '%toy%'；
2．反过来再来一次。编写SQL语句，从Products表中检索产品名称（prod_name）和描述（prod_desc），仅返回描述中未出现toy一词的产品。这次，按产品名称对结果进行排序。

select prod_name, prod_desc from Products where not prod_desc like '%toy%' order by prod_name;
3．编写SQL语句，从Products表中检索产品名称（prod_name）和描述（prod_desc），仅返回描述中同时出现toy和carrots的产品。有好几种方法可以执行此操作，但对于这个挑战题，请使用AND和两个LIKE比较。

select prod_name, prod_desc from Products where prod_desc like '%toy%' and  prod_desc like '%carrots%';
4．来个比较棘手的。我没有特别向你展示这个语法，而是想看看你根据目前已学的知识是否可以找到答案。编写SQL语句，从Products表中检索产品名称（prod_name）和描述（prod_desc），仅返回在描述中以先后顺序同时出现toy和carrots的产品。提示：只需要用带有三个%符号的LIKE即可。

select prod_name, prod_desc from Products where prod_desc like '%toy%carrots%';
课7 创建计算字段

1．别名的常见用法是在检索出的结果中重命名表的列字段（为了符合特定的报表要求或客户需求）。编写SQL语句，从Vendors表中检索vend_id、vend_name、vend_address和vend_city，将vend_name重命名为vname，将vend_city重命名为vcity，将vend_address重命名为vaddress。按供应商名称对结果进行排序（可以使用原始名称或新的名称）。

select 
vend_id,
vend_name vname,
vend_city vcity,
vend_address vaddress
from Vendors
order by vname;
2．我们的示例商店正在进行打折促销，所有产品均降价10%。编写SQL语句，从Products表中返回prod_id、prod_price和sale_price。sale_price是一个包含促销价格的计算字段。提示：可以乘以0.9，得到原价的90%（即10%的折扣）

select prod_id, prod_price, prod_price*0.9 as sale_price from Products;
课8 使用函数处理数据

1．我们的商店已经上线了，正在创建顾客账户。所有用户都需要登录名，默认登录名是其名称和所在城市的组合。编写SQL语句，返回顾客ID（cust_id）、顾客名称（customer_name）和登录名（user_login），其中登录名全部为大写字母，并由顾客联系人的前两个字符（cust_contact）和其所在城市的前三个字符（cust_city）组成。例如，我的登录名是BEOAK（Ben Forta，居住在Oak Park）。提示：需要使用函数、拼接和别名。

select 
cust_id, cust_name,
-- upper(left(cust_contact,2)||left(cust_city,3)) as login_name
-- upper(left(cust_contact,2)+left(cust_city,3)) as login_name
-- upper(substr(cust_contact,1,2)||substr(cust_city,1,3)) as login_name
upper(concat(left(cust_contact,2), left(cust_city,3))) as login_name
from customers;
2．编写SQL语句，返回2020年1月的所有订单的订单号（order_num）和订单日期（order_date），并按订单日期排序。你应该能够根据目前已学的知识来解决此问题，但也可以开卷查阅DBMS文档。

select order_num, order_date 
from orders 
where extract(year from order_date)=2020 and extract(month from order_date)=1
-- where year(order_date)=2020 and month(order_date)=01 
order by order_date;
课9 汇总数据

1．编写SQL语句，确定已售出产品的总数（使用OrderItems中的quantity列）。

select sum(quantity) from orderitems;
2．修改刚刚创建的语句，确定已售出产品项（prod_item）BR01的总数。

select sum(quantity) from orderitems where prod_id = 'BR01';
3．编写SQL语句，确定Products表中价格不超过10美元的最贵产品的价格（prod_price）。将计算所得的字段命名为max_price。

select max(prod_price) as max_price from products where prod_price<=10;
课10 分组数据

1．OrderItems表包含每个订单的每个产品。编写SQL语句，返回每个订单号（order_num）各有多少行数（order_lines），并按order_lines对结果进行排序。

select order_num, count(*) order_lines from orderitems group by order_num order by order_lines;
2．编写SQL语句，返回名为cheapest_item的字段，该字段包含每个供应商成本最低的产品（使用Products表中的prod_price），然后从最低成本到最高成本对结果进行排序。

select vend_id, min(prod_price) cheapest_item from products group by vend_id order by prod_price;
3．确定最佳顾客非常重要，请编写SQL语句，返回至少含100项的所有订单的订单号（OrderItems表中的order_num）。

select order_num from orderitems group by order_num having sum(quantity)>=100;
4．确定最佳顾客的另一种方式是看他们花了多少钱。编写SQL语句，返回总价至少为1000的所有订单的订单号（OrderItems表中的order_num）。提示：需要计算总和（item_price乘以quantity）。按订单号对结果进行排序。

select order_num from orderitems group by order_num having sum(item_price * quantity) >=1000 order by order_num;
5．下面的SQL语句有问题吗？（尝试在不运行的情况下指出。）

SELECT order_num, COUNT(＊) AS items
FROM OrderItems
GROUP BY items             -- -----------------group by order_num
HAVING COUNT(＊) >= 3
ORDER BY items, order_num;
课11 使用子查询

1．使用子查询，返回购买价格为10美元或以上产品的顾客列表。你需要使用OrderItems表查找匹配的订单号（order_num），然后使用Order表检索这些匹配订单的顾客ID（cust_id）。

select cust_id from orders
where order_num in(
select order_num from orderitems
where item_price >=10
);
2．你想知道订购BR01产品的日期。编写SQL语句，使用子查询来确定哪些订单（在OrderItems中）购买了prod_id为BR01的产品，然后从Orders表中返回每个产品对应的顾客ID（cust_id）和订单日期（order_date）。按订购日期对结果进行排序。

select cust_id, order_date 
from orders
where order_num in (
select order_num 
from orderitems 
where prod_id = 'BR01')
order by order_date;

# 同12课第3题。使用的方法不同，表连接
select
o.cust_id,
o.order_date
from orders o
inner join OrderItems oi on o.order_num = oi.order_num
where oi.prod_id = 'BR01'
order by o.order_date;
3．现在我们让它更具挑战性。在上一个挑战题，返回购买prod_id为BR01的产品的所有顾客的电子邮件（Customers表中的cust_email）。提示：这涉及SELECT语句，最内层的从OrderItems表返回order_num，中间的从Customers表返回cust_id。

select cust_email from customers
where cust_id in(
select cust_id from orders where order_num in (
select order_num from orderitems where prod_id = 'BR01'
)
);

# 同12课挑战题4，使用表连接
select
cu.cust_email
from customers cu
inner join orders od on od.cust_id = cu.cust_id
inner join orderitems oi on oi.order_num = od.order_num
where oi.prod_id = 'BR01';
4．我们需要一个顾客ID列表，其中包含他们已订购的总金额。编写SQL语句，返回顾客ID（Orders表中的cust_id），并使用子查询返回total_ordered以便返回每个顾客的订单金额。将结果按金额从大到小排序。提示：你之前已经使用SUM()计算订单金额。

select cust_id,
(select sum(item_price*quantity)
from orderitems
where orders.order_num = orderitems.order_num) as total_ordered
from orders
order by total_ordered desc;
5．再来。编写SQL语句，从Products表中检索所有的产品名称（prod_name），以及名为quant_sold的计算列，其中包含所售产品的总数（在OrderItems表上使用子查询和SUM(quantity)检索）

select prod_name,
(select sum(quantity)
from orderitems
where orderitems.prod_id = products.prod_id) as quant_sold
from products
order by quant_sold desc;
课12 联结表

1．编写SQL语句，返回Customers表中的顾客名称（cust_name）和Orders表中的相关订单号（order_num），并按顾客名称再按订单号对结果进行排序。实际上是尝试两次，一次使用简单的等联结语法，一次使用INNER JOIN。

select
c.cust_name,
o.order_num
from customers c inner join orders o on c.cust_id = o.cust_id
order by c.cust_name,o.order_num;


selectcust_name, order_num
from Customers, Orders
where Customers.cust_id = Orders.cust_id
order by cust_name, order_num;
2．我们来让上一题变得更有用些。除了返回顾客名称和订单号，添加第三列OrderTotal，其中包含每个订单的总价。有两种方法可以执行此操作：使用OrderItems表的子查询来创建OrderTotal列，或者将OrderItems表与现有表联结并使用聚合函数。提示：请注意需要使用完全限定列名的地方。

select
c.cust_name,
o.order_num,
sum(oi.item_price * oi.quantity) as OrderTotal
from customers c 
inner join orders o on c.cust_id = o.cust_id
inner join OrderItems oi on oi.order_num = o.order_num
group by c.cust_name,o.order_num;

select
c.cust_name,
o.order_num,
(select sum(oi.item_price * oi.quantity) from orderitems oi
where oi.order_num = o.order_num
) as OrderTotal
from customers c inner join orders o on c.cust_id = o.cust_id
order by c.cust_name,o.order_num;
3．我们重新看一下第11课的挑战题2。编写SQL语句，检索订购产品BR01的日期，这一次使用联结和简单的等联结语法。输出应该与第11课的输出相同。

select
o.cust_id,
o.order_date
from orders o
inner join OrderItems oi on o.order_num = oi.order_num
where oi.prod_id = 'BR01'
order by o.order_date;
4．很有趣，我们再试一次。重新创建为第11课挑战题3编写的SQL语句，这次使用ANSI的INNER JOIN语法。在之前编写的代码中使用了两个嵌套的子查询。要重新创建它，需要两个INNER JOIN语句，每个语句的格式类似于本课讲到的INNER JOIN示例，而且不要忘记WHERE子句可以通过prod_id进行过滤。

select
cu.cust_email
from customers cu
inner join orders od on od.cust_id = cu.cust_id
inner join orderitems oi on oi.order_num = od.order_num
where oi.prod_id = 'BR01';
5．再让事情变得更加有趣些，我们将混合使用联结、聚合函数和分组。准备好了吗？回到第10课，当时的挑战是要求查找值等于或大于1000的所有订单号。这些结果很有用，但更有用的是订单数量至少达到这个数的顾客名称。因此，编写SQL语句，使用联结从Customers表返回顾客名称（cust_name），并从OrderItems表返回所有订单的总价。提示：要联结这些表，还需要包括Orders表（因为Customers表与OrderItems表不直接相关，Customers表与Orders表相关，而Orders表与OrderItems表相关）。不要忘记GROUP BY和HAVING，并按顾客名称对结果进行排序。你可以使用简单的等联结或ANSI的INNER JOIN语法。或者，如果你很勇敢，请尝试使用两种方式编写

select
cu.cust_name,
sum(oi.item_price * oi.quantity) as toatl_price
from customers cu
inner join orders od on od.cust_id = cu.cust_id
inner join orderitems oi on oi.order_num = od.order_num
group by cu.cust_name having toatl_price>=1000
order by cu.cust_name;
课13 创建高级联结

1．使用INNER JOIN编写SQL语句，以检索每个顾客的名称（Customers表中的cust_name）和所有的订单号（Orders表中的order_num）。

select
cu.cust_name,
od.order_num
from customers cu
join orders od on od.cust_id = cu.cust_id
order by cu.cust_name;
2．修改刚刚创建的SQL语句，仅列出所有顾客，即使他们没有下过订单。

select cust_name,
od.order_num
from customers cu
left join orders od on od.cust_id = cu.cust_id
order by cust_name;
3．使用left OUTER JOIN联结Products表和OrderItems表，返回产品名称（prod_name）和与之相关的订单号（order_num）的列表，并按商品名称排序。

select
p.prod_name,
oi.order_num 
from products p
left join orderitems oi on p.prod_id = oi.prod_id
order by p.prod_name;
4．修改上一题中创建的SQL语句，使其返回每一项产品的总订单数（不是订单号）。

select
p.prod_name,
count(oi.order_num) as total_order
from products p
left join orderitems oi on p.prod_id = oi.prod_id
group by p.prod_name
order by p.prod_name;
5．编写SQL语句，列出供应商（Vendors表中的vend_id）及其可供产品的数量，包括没有产品的供应商。你需要使用OUTER JOIN和COUNT()聚合函数来计算Products表中每种产品的数量。注意：vend_id列会显示在多个表中，因此在每次引用它时都需要完全限定它。

select
v.vend_id,
count(p.prod_id) as products
from Vendors v
left join products p on v.vend_id = p.vend_id
group by v.vend_id;
课14 组合查询

1．编写SQL语句，将两个SELECT语句结合起来，以便从OrderItems表中检索产品ID（prod_id）和quantity。其中，一个SELECT语句过滤数量为100的行，另一个SELECT语句过滤ID以BNBG开头的产品。按产品ID对结果进行排序。

select prod_id, quantity from orderitems where quantity = 100
union
select prod_id, quantity from orderitems where prod_id like 'BNBG%'
order by prod_id;
2．重写刚刚创建的SQL语句，仅使用单个SELECT语句。

select
prod_id, quantity
from orderitems
where quantity=100 or prod_id like 'BNBG%'
order by prod_id;
3．我知道这有点荒谬，但这节课中的一个注释提到过。编写SQL语句，组合Products表中的产品名称（prod_name）和Customers表中的顾客名称（cust_name）并返回，然后按产品名称对结果进行排序。

select prod_name from products
union
select cust_name from customers
order by prod_name; 
4．下面的SQL语句有问题吗？（尝试在不运行的情况下指出。）

SELECT cust_name, cust_contact, cust_email
FROM Customers
WHERE cust_state = 'MI'
ORDER BY cust_name;  # 错误1
UNION
SELECT cust_name, cust_contact, cust_email
FROM Customers
WHERE cust_state = 'IL'ORDER BY cust_name;


# 改正
SELECT cust_name, cust_contact, cust_email
FROM Customers
WHERE cust_state = 'MI'
UNION
SELECT cust_name, cust_contact, cust_email
FROM Customers
WHERE cust_state = 'IL'ORDER BY cust_name;
课15 插入数据

1．使用INSERT和指定的列，将你自己添加到Customers表中。明确列出要添加哪几列，且仅需列出你需要的列。

insert into customers(
cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_email
)
values(
1000000033,'Socool','388 Peaceful place','Columbus','CH','231000','CH','0000@fun.com'
);
2．备份Orders表和OrderItems表。

create table ordersBackup as select * from orders;
create table orderitemsBackup as select * from orderitems;
课16 更新和删除数据

1．美国各州的缩写应始终用大写。编写SQL语句来更新所有美国地址，包括供应商状态（Vendors表中的vend_state）和顾客状态（Customers表中的cust_state），使它们均为大写。

如果运行报错1175 safe_update……什么的，这是因为mysql是在safe-updates模式下，该模式下导致无法在非主键条件下进行update和delete操作。可以执行 SET SQL_SAFE_UPDATES = 0 修改该模式，SET SQL_SAFE_UPDATES = 1恢复安全更新模式。
update vendors set vend_state = upper(vend_state) where vend_country = 'USA'; 
update customers set cust_state = upper(cust_state) where cust_country = 'USA'; 
2．第15课的挑战题1要求你将自己添加到Customers表中。现在请删除自己。确保使用WHERE子句（在DELETE中使用它之前，先用SELECT对其进行测试），否则你会删除所有顾客！

delete from customers where cust_id = 1000000033;
课17 创建和操纵表

1．在Vendors表中添加一个网站列（vend_web）。你需要一个足以容纳URL的大文本字段。

alter table vendors add vend_web char(100);
2．使用UPDATE语句更新Vendor记录，以便加入网站（你可以编造任何地址）。

update vendors set vend_web = 'http://baidu.com'
where vend_id = 'BRS01';
课18 使用视图

1．创建一个名为CustomersWithOrders的视图，其中包含Customers表中的所有列，但仅仅是那些已下订单的列。提示：可以在Orders表上使用JOIN来仅仅过滤所需的顾客，然后使用SELECT来确保拥有正确的数据。

create view CustomersWithOrders as
select
customers.*
from customers
join orders on orders.cust_id = customers.cust_id;
2．下面的SQL语句有问题吗？（尝试在不运行的情况下指出。）

CREATE VIEW OrderItemsExpanded AS
SELECT order_num,
       prod_id,
       quantity,
       item_price,
       quantity＊item_price AS expanded_price
FROM OrderItems
ORDER BY order_num;
这个语句不能说一定有问题，在我的workbench里运行可以通过，在有些DBMS里运行可能会报错，报错的原因是建立视图的时候不能用也没必要用order by语句，注意一下就行。

三、SQL高级特性

SQL的高级数据处理特性：约束、索引、触发器。

3.1 约束

管理如何插入或处理数据库数据的规则。


SQL的约束
如何创建几种约束？

-- 主键约束 创建方式1
CREATE TABLE Vendors(
vend_id           CHAR(10)        NOT NULL PRIMARY KEY,---------------------------创建表的时候定义  PRIMARY KEY
vend_name        CHAR(50)        NOT NULL,
vend_address     CHAR(50)        NULL,
vend_city        CHAR(50)        NULL,
vend_state       CHAR(5)          NULL,
vend_zip          CHAR(10)        NULL,
vend_country     CHAR(50)        NULL
    );

-- 主键约束 创建方式2
ALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY (vend_id); ------------------- 更新表的时候创建 CONSTRAINT PRIMARY KEY


-- 外键约束 创建方式1
CREATE TABLE Orders(
order_num     INTEGER     NOT NULL PRIMARY KEY,
order_date    DATETIME    NOT NULL,
cust_id       CHAR(10)    NOT NULL REFERENCES Customers(cust_id));


-- 外键约束  创建方式2
ALTER TABLE Orders ADD CONSTRAINT FOREIGN KEY (cust_id) REFERENCES Customers (cust_id);

-- 检查约束  创建方式1
CREATE TABLE OrderItems(
order_num      INTEGER      NOT NULL,
order_item     INTEGER      NOT NULL,
prod_id        CHAR(10)     NOT NULL,
quantity       INTEGER      NOT NULL CHECK (quantity > 0),
item_price     MONEY        NOT NULL);

-- 检查约束 创建方式2
ALTER TABLE OrderItems ADD CONSTRAINT CHECK (gender LIKE '[MF]');
3.2 索引

索引是用来排序数据以加快检索和排序的速度。

索引能够加快查询速度，但是降低了数据插入、更新、删除的性能，需时常检查动态更新。

索引数据可能占用大量存储空间。

并不是所有的数据都适合做索引，一般来说取值更多元的列比取值不多的数据更适合。比如姓名，用户id。

索引用于数据过滤或数据排序。如果经常以某种特定顺序排序数据，则该数据适合做索引。

可以在所有中定义多个列。

-- 创建索引：
create index prod_name_ind on products(prod_name);
3.3 触发器

触发器是特殊的存储过程，在特定的数据库活动发生时自动执行。触发器可以与特定表上的insert、update、delete操作（或组合）相关联。

常见用途：保证数据一致、基于某个表的变动在其他表上执行活动、进行额外的验证并需要回退数据、计算计算列的值或更新时间戳。

创建触发器：不同的DBMS创建方式大有不同。举例MySQL创建方式，对所有insert和update操作，将customers表中的cust_state列转换为大写。

create trigger customer_state on customers for insert,update
as
update customers
set cust_state = upper(cust_state)
where customer.cust_id = inserted.cust_id;
一般来说，约束的处理比触发器快，因此尽量使用约束。
